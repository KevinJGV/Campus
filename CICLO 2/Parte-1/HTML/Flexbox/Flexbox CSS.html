<!DOCTYPE html><html
lang="pt-BR"><head><meta
charset="UTF-8"><meta
name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1.0"><title>Flexbox CSS</title><meta
</head>
<body
class=" blackfriday"><div
class="cosmos-container cosmos-content"><p>Flexbox tiene como meta ser una forma más eficiente de crear diseños, alinear y distribuir espacios entre ítems en un contenedor, incluso cuando las dimensiones de esos ítems son desconocidas y/o dinámicas (en virtud de eso el término &quot;flex&quot;).</p><p>Aprendamos los fundamentos de CSS Flexbox para la alineación y el posicionamiento, y cómo usar sus funcionalidades correctamente.</p><h4><strong>Qué es el</strong> <strong><em>Flexbox</em></strong></h4><p>Durante mucho tiempo, las únicas herramientas disponibles para crear diseños CSS y posicionar elementos con buena compatibilidad entre browsers eran float y position. Sin embargo, estas herramientas tienen algunas limitaciones muy frustrantes, especialmente cuando se trata de responsividad. Algunas tareas que consideramos básicas en un diseño, como centrar verticalmente un elemento secundario en relación con un elemento principal o hacer que los elementos secundarios ocupen la misma cantidad de espacio, o que las columnas tengan el mismo tamaño independientemente de la cantidad de contenido interno, fueron imposibles. o muy difícil de manejar con floats o position, al menos de forma práctica y <em>flexible</em>. La herramienta Flexbox (de <em>Flexible Box</em>) fue creada para hacer estas tareas más sencillas y funcionales: los secundarios de un elemento con Flexbox se pueden posicionar en cualquier dirección y pueden tener dimensiones flexibles para adaptarse.</p><h4><strong>Elementos</strong></h4><p>Flexbox es un módulo completo y no una propiedad única; algunos de ellos deben declararse en el contenedor (el elemento principal, que llamamos de <em>flex container</em>), mientras que otros deben declararse en los elementos secundarios (el <em>flex ítems</em>). Si el diseño &quot;estándar&quot; se basa en las direcciones <code>block</code> e <code>inline</code>, el diseño Flex se basa en direcciones de &quot;flex flow&quot;. A continuación se muestra un diagrama de la especificación, que explica la idea central detrás del diseño Flex.</p>
<img
src="https://camo.githubusercontent.com/12ac134bb129d3a276a9c1ed9fd066cf23c9b193f528fd29b2ad1c4cc9d6a172/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31312f30302d62617369632d7465726d696e6f6c6f67792e737667" alt="Diagrama explicando a terminologia do Flex. A dimensão no sentido do eixo principal é chamada de tamanho principal, e a outra direção é chamada de transversal. Estes tamanhos, tanto o principal como o transversa, têm uma borda inicial e uma borda final" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /><p>Los ítems se distribuirán en el diseño siguiendo el eje principal o transversal.</p><ul><li><p>Eje principal: el eje principal de un <em>flex container</em> es el eje primario y a lo largo de él son insertados los <em>flex ítems</em>. <strong>Precaución</strong>: El eje principal no es necesariamente horizontal; Dependerá de la propiedad <code>flex-direction</code> (vea abajo).</p></li><li><p><em>Main-start | main-end</em>: los <em>flex ítems</em> se insertan en el contenedor empezando por el lado <em>start</em>, dirigiéndose hacia el lado <em>end</em>.</p></li><li><p>Tamaño principal: El ancho o alto de un <em>flex ítem</em>, dependiendo de la dirección del contenedor, es el tamaño principal del ítem. La propiedad de tamaño principal de un <em>flex ítem</em> puede ser tanto <code>width</code> como <code>height</code>, dependiendo de cuál esté en la dirección principal.</p></li><li><p>Eje transversal: El eje perpendicular al eje principal se llama eje transversal. Su dirección depende de la dirección del eje principal.</p></li><li><p><em>Cross-start | cross-end</em>: Líneas flex se llenan con ítems y se agregan al contenedor, comenzando desde el lado <em>cross start</em> del <em>flex container</em> hacia el lado <em>cross end</em>.</p></li><li><p><em>Cross size</em>: El ancho o alto de un <em>flex ítem</em>, dependiendo de lo que haya en la dimensión transversal, es el <em>cross size</em> del ítem. La propiedad <em>cross size</em> puede ser el ancho o el alto del ítem, lo que se encuentre en la transversal.</p><p><strong>Flex container</strong> es el elemento que involucra su estructura. Tu defines que un elemento es un Flex Container con la propiedad <code>display</code> y valores <code>flex</code> o <code>inline-flex</code>.</p><p><code>&lt;div class="flex-container"&gt;</code></p><p><code>&lt;div&gt;1&lt;/div&gt;</code></p><p><code>&lt;div&gt;2&lt;/div&gt;</code></p><p><code>&lt;div&gt;3&lt;/div&gt;</code></p><p><code>&lt;/div&gt;</code></p><p><code>.flex-container {</code></p><p><code>display: flex;</code></p><p><code>}</code></p><p><strong>Flex Ítem</strong> son elementos secundarios del flex container.</p><p><strong>Ejes o Axes</strong> son las dos direcciones básicas que existen en un Flex Container: <em>main axis</em>, o eje principal, y <em>cross axis</em>, o eje transversal.</p><h4><strong>Propiedades del elemento principal</strong></h4>
<img
src="https://camo.githubusercontent.com/a21eff89a381a6f8470c4b0952874cbdf45b3486b3afe084b6f75095acd9c8d9/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f30312d636f6e7461696e65722e737667" alt="container flex" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /><p>Cuando usamos el <em>Flexbox</em>, es muy importante saber qué propiedades se declaran en el elemento principal (por ejemplo, una div que contendrá los elementos a alinear) y cuáles se declararán en los elementos secundarios. A continuación, se muestran las propiedades que deben declararse utilizando el elemento principal como selector (para alinear los elementos secundarios):</p><p><strong>Display</strong></p><p>Esta propiedad define un <em>flex container</em>; inline o block dependiendo de los valores pasados. Coloca todos los elementos secundarios directos en un contexto Flex.</p><p><code>.container {</code></p><p><code>display: flex; */\* or inline-flex \*/*</code></p><p><code>}</code></p><p>Tenga en cuenta que la propiedad CSS <code>columns</code> no tiene efecto en un <em>flex container</em>.</p><p><strong>Flex-direction</strong></p>
<img
src="https://camo.githubusercontent.com/9ece155a18899ad915ccef5da80f618006b82c49277beea200e22c1f70d966da/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f666c65782d646972656374696f6e2e737667" alt="flex-direction" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /><p>Establece el eje principal, definiendo así la dirección en la que los <em>flex ítems</em> están alineados en el <em>flex container</em>. Flexbox es (con la excepción de un wrapping opcional) un concepto de diseño unidireccional. Piensa en los <em>flex ítems</em> inicialmente posicionaids o en líneas horizontales o en columnas verticales.</p><p><code>.flex-container {  flex-direction: row | row-reverse | column | column-reverse; }</code></p><ul><li><p><code>row</code> (estándar): de la izquierda a la derecha en <code>ltr</code> (left to right), de la derecha a la izquierda en rtl (right to left)</p></li><li><p><code>row-reverse</code>: de la derecha a la izquierda en <code>ltr</code>, de la izquierda a la derecha en <code>rtl</code></p></li><li><p><code>column:</code> mismo que <code>row</code>, pero de arriba a abajo</p></li><li><p><code>column-reverse</code>: mismo que <code>row-reverse</code> pero de abajo hacia arriba</p></li></ul><p><strong>flex-wrap</strong></p>
<img
src="https://camo.githubusercontent.com/fd3727f675a455a68ce92ed75cf57ff202447fd18f730f7978b80a3bb0e79638/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f666c65782d777261702e737667" alt="flex-wrap" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /><p>Por estándar, los <em>flex ítems</em> todos intentarán encajarse en una sola línea. Con esta propiedad puedes modificar este comportamiento y permitir que los ítems pasen a la siguiente línea según sea necesario.</p><p><code>.flex-container {</code></p><p><code>flex-wrap: nowrap | wrap | wrap-reverse;</code></p><p><code>}</code></p><ul><li><p><code>nowrap</code> (estándar): todos los <em>flex ítems</em> estarán en una sola línea</p></li><li><p><code>wrap</code>: los <em>flex ítems</em> se dividirán en múltiples líneas, de arriba a abajo</p></li><li><p><code>wrap-reverse</code>: los <em>flex ítems</em> se dividirán en múltiples líneas de abajo hacia arriba</p></li></ul><p><strong>flex-flow</strong></p><ul><li>La propiedad <strong>flex-flow</strong> es una propiedad <em>shorthand</em> (una misma declaración incluye varios valores relacionados con más de una propiedad) que incluye flex-direction y flex-wrap. Determina cuáles serán los ejes principal y transversal del contenedor. El valor estándar es row nowrap.</li></ul><p><code>.flex-container {  flex-flow: row nowrap | row wrap | column nowrap | column wrap; }</code></p><p><strong>Justify-content</strong></p>
<img
src="https://camo.githubusercontent.com/99c142d1b528f7c33757152139ff8131358dc3ddb77eb3b2a6fc9a044d2bb53e/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f6a7573746966792d636f6e74656e742e737667" alt="justify-content" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /><p>Esta propiedad define la alineación de los ítems a lo largo del eje principal. Ayuda a distribuir el espacio libre que queda en el contenedor, ya sea que todos los flex ítems de una línea sean inflexibles o flexibles, pero ya hayan alcanzado su tamaño máximo. También ejerce cierto control sobre la alineación de los ítems cuando sobrepasan el límite de la línea.</p><p><code>.flex-container {</code></p><p><code>justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;</code></p><p><code>}</code></p><ul><li><p><code>flex-start</code> (estándar): los ítems se alinean a lo largo del borde de inicio (start) de acuerdo con la <code>flex-direction</code> del contenedor.</p></li><li><p><code>Flex-end</code>: los ítems se alinean a lo largo del borde final (end) de acuerdo con la <code>flex-direction</code> del contenedor.</p></li><li><p><code>start:</code> los ítems se alinean a lo largo del borde de inicio de la dirección del writing-mode (modo de escritura).</p></li><li><p><code>end</code>: los ítems se alinean a lo largo del borde final de la dirección del writing-mode (modo de escritura).</p></li><li><p><code>left:</code> los ítems están alineados a lo largo del borde izquierdo del contenedor, a menos que esto no tenga sentido con el <code>flex-direction</code> que se está utilizando. En este caso, se comporta como <code>start</code>.</p></li><li><p><code>right:</code> los ítems están alineados a lo largo del borde derecho del contenedor, a menos que esto no tenga sentido con el <code>flex-direction</code> que se está utilizando. En este caso, se comporta como <code>start</code>.</p></li><li><p><code>center:</code> los ítems están centrados en la línea.</p></li><li><p><code>Space-between:</code> los ítems se distribuyen uniformemente a lo largo de la línea; el primer ítem al lado del borde inicial de la línea, el último ítem al lado del borde final de la línea.</p></li><li><p><code>Space-around:</code> los ítems se distribuyen en línea con el mismo espacio entre ellos. Tenga en cuenta que visualmente el espacio puede no ser igual, ya que todos los ítems tienen la misma cantidad de espacio en ambos lados: el primer ítem solo tendrá una unidad de espacio a lo largo del borde del contenedor, pero dos unidades de espacio entre él y el siguiente ítem, porque el ítem siguiente también tiene su propio espaciamiento que se está aplicando.</p></li><li><p><code>Space-evenly:</code> los ítems se distribuyen de manera que el espacio entre dos elementos cualesquiera en la línea (incluso entre los ítems y los bordes) sea igual.</p></li></ul><p>Nota: el soporte dado por los navegadores para estos valores es difuso. Por ejemplo, space-between no tiene soporte en ninguna versión de Edge (hasta la elaboración de este tutorial) y start / end / left / right aún no se han implementado en Chrome. Para obtener tablas detalladas, consulte MDN. Los valores más seguros son flex-start, flex-end y center.</p><p>También hay dos palabras clave adicionales que puedes usar junto con estos valores:  <code>safe y unsafe</code>. Safe asegura que, independiente de cómo hagas este tipo de posicionamiento, no sea posible &quot;empujar&quot; un elemento y hacer con que sea renderizado hacia afuera de la pantalla (por ejemplo, sobre el tope) de una manera que haga con que el contenido sea imposible de mover con el desplazamiento de la pantalla (el CSS llama a esto de &quot;pérdida de datos&quot;).</p><p><strong>Align-ítems</strong></p><p><a
href="https://camo.githubusercontent.com/6a31df6631678ba5686f4ec6203cd74c094924517b8b8a1f21981f26fb21eccf/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f616c69676e2d6974656d732e737667" target="_blank" rel="noopener"><img
src="https://camo.githubusercontent.com/6a31df6631678ba5686f4ec6203cd74c094924517b8b8a1f21981f26fb21eccf/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f616c69676e2d6974656d732e737667" alt="align-items" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /></a></p><p>Establece el comportamiento estándar de cómo <em>flex ítems</em> están alineados según el eje transversal (<em>cross axis</em>). En cierto modo, funciona de manera similar al justify-content, pero en el eje transversal (perpendicular al eje principal).</p><p><code>. .flex-container {</code></p><p><code>align-items: stretch | flex-start | flex-end | center | baseline;</code></p><p><code>}</code></p><ul><li><p><code>Stretch</code> (estándar): estira los ítems para llenar el contenedor, respetando el <code>min-width/max-width</code>).</p></li><li><p><code>Flex-start/start/self-start:</code> ítems se posicionan al inicio del eje transversal. La diferencia entre ellos es sutil y se refiere a las reglas de <code>flex-direction</code> o <code>writing-mode</code>.</p></li><li><p><code>center</code>: ítems se centran en el eje transversal.</p></li><li><p><code>baseline:</code> ítems se alinean de acuerdo con sus baselines.</p></li></ul><p>Los modificadores <code>safe y unsafe</code> se puede usar junto con todas estas palabras clave (por favor verifique el soporte de cada navegador) y sirven para evitar cualquier alineación de elementos que haga con que el contenido sea inaccesible (por ejemplo, fuera de la pantalla).</p><p><strong>align-content</strong></p>
<img
src="https://camo.githubusercontent.com/b3b9b868dc5b3bbb69ecd7ea7a950f7b33ca346d4c761d555717ec8b340bb966/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f616c69676e2d636f6e74656e742e737667" alt="align-content" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /><p>Organiza las líneas dentro de un flex container cuando hay espacio adicional en el eje transversal, similar a cómo <code>justify-content</code> alinea ítems individuales dentro del eje principal.</p><p><strong>Importante</strong>: Esta propiedad no tiene efecto cuando solo hay una línea de flex ítems en el contenedor.</p><p><code>.flex-container {</code></p><p><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</code></p><p><code>}</code></p><ul><li><p><code>flex-start / start:</code> ítems alineados con el inicio del contenedor. El valor (con mayor soporte de los navegadores) flex-start se guía por la flex-direction, mientras que start se guía por la dirección del writing-mode.</p></li><li><p><code>Flex-end/end:</code> ítems alineados con el final del contenedor. El valor (con mayor soporte de los navegadores) flex-end se guía por la flex-direction, mientras que end se guía por la dirección del writing-mode.</p></li><li><p><code>center</code>: ítems centrados en el contenedor.</p></li><li><p><code>space-between</code>: ítems distribuidos uniformemente; la primera línea al inicio del contenedor y la última línea al final del contenedor.</p></li><li><p><code>space-around</code>: ítems distribuidos uniformemente con el mismo espaciamiento entre cada línea.</p></li><li><p><code>space-evenly:</code> elementos distribuidos uniformemente con el mismo espaciamiento entre ellos.</p></li><li><p><code>stretch</code> (estándar): ítems en cada línea se estiran para ocupar el espacio remanente entre ellas.</p></li></ul><p>Los modificadores <code>safe y unsafe</code> se puede usar junto con todas estas palabras clave (por favor verifique el soporte de cada navegador) y sirven para evitar cualquier alineación de elementos que haga con que el contenido sea inaccesible (por ejemplo, fuera de la pantalla).</p><h4><strong>Propiedades de los elementos secundarios</strong></h4><p>A continuación, veremos propiedades que deben declararse teniendo como selector los elementos secundarios, es decir:</p><div
class="flex-container"><div
class="flex-item">1</div><div
class="flex-item">2</div><div
class="flex-item">3</div></div><p>Esto significa que, donde hay un elemento principal con propiedad <em>flex</em> (o <em>flex-container</em>), también puede asignar propiedades flex específicas a elementos secundarios (<em>flex-ítem</em>).</p><p>Puede definir las propiedades a continuación para solo uno de los elementos secundarios a través de un identificador, como una clase específica.</p><h4><strong>order</strong></h4><p>Determina el orden en que aparecerán los elementos.</p>
<img
src="https://camo.githubusercontent.com/0a50368a4fd1553a70dfebf0937b7caf8354a83cae32097c2229822a277e3f08/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f6f726465722e737667" alt="order" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /><p>Por estándar los flex ítems, se organizan en la pantalla en orden de código. Pero la propiedad order controla el orden en que aparecen en el contenedor.</p><p><code>.flex-item {</code></p><p><code>order: &lt;número&gt;; */\* el valor estándar es 0 \*/*</code></p><p><code>}</code></p><h4><strong>Flex-grow</strong></h4>
<img
src="https://camo.githubusercontent.com/79e51e3724731b3f5f1597aaad21f9820bebcd30dcbe4c6ae546499694381b1e/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f666c65782d67726f772e737667" alt="grow" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /><p>Define la habilidad de un flex ítem de crecer, según el caso. El valor de esta propiedad es un valor numérico sin indicación de unidad, que se utiliza para calcular la proporción. Este valor dicta la cantidad de espacio disponible en el contenedor que ocupará el ítem.</p><p>Si todos los ítems tienen flex-grow establecido en 1, el espacio remanente en el contenedor se distribuirá de manera uniforme entre todos. Si uno de los ítems tiene el valor 2, ocupará el doble de espacio en el contenedor que los demás (o al menos intentará hacerlo).</p><p><code>.flex-item {</code></p><p><code>flex-grow: &lt;numero&gt;; */\* el valor default(estándar) es 0 \*/*</code></p><p><code>}</code></p><p>La propiedad no acepta valores negativos.</p><h4><strong>flex-shrink</strong></h4><p>Establece la habilidad de un flex ítem para contraerse, según el caso. <code>.flex-item {</code></p><p><code>flex-shrink: &lt;número&gt;; */\* el valor estándar es 0 \*/* }</code></p><p>La propiedad no acepta valores negativos.</p><p><strong>flex-basis</strong></p><p>Establece el tamaño estándar de un elemento antes de que se distribuya el espacio remanente del contenedor. Puede ser un largo (por ejemplo, 20%, 5rem, etc.) o una palabra clave. La palabra clave auto significa &quot;observe mis propiedades de altura o ancho&quot; (lo que era hecho por la palabra clave <code>t main-size</code>, que fue depreciada). La palabra clave <code>content</code> significa &quot;establezca el tamaño según el contenido interno del ítem&quot;; esta palabra clave aún no tiene mucho soporte, por lo que no es fácil de probar, al igual que sus relacionadas: <code>max-content, min-content y fit-content.</code></p><p><code>.flex-item {</code></p><p><code>flex-basis: flex-basis: | auto; */\* el valor estándar es auto \*/*</code></p><p><code>}</code></p><p>Con el valor 0, el espacio adicional alrededor del contenido no se considera. Con el valor de auto, el espacio adicional se distribuye con base en el valor de <code>flex-grox</code> del ítem.</p><p><strong>flex</strong></p><p>Esta es la propiedad <em>shorthand</em> para <code>flex-grow, flex-shrink y flex-basis</code>, combinadas. El segundo y tercer parámetros <code>(flex-shrink y flex-basis)</code> son opcionales. El estándar es <code>0 1 auto</code>, pero si lo defines con un solo número, es equivalente a <code>0 1</code>.</p><p><code>.item {</code></p><p><code>flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</code></p><p><code>}</code></p><p><strong>Se recomienda que utilices esta propiedad</strong> <strong><em>shorthand</em></strong> en lugar de definir cada una de las propiedades por separado. <em>Shorthand</em> establece los demás valores de forma inteligente.</p><p><strong>align-self</strong></p><p><a
href="https://camo.githubusercontent.com/634a0654d355ea5af43d1bd868604176e01f726de196c4868dc0e0b80f3eee1f/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f616c69676e2d73656c662e737667" target="_blank" rel="noopener"><img
src="https://camo.githubusercontent.com/634a0654d355ea5af43d1bd868604176e01f726de196c4868dc0e0b80f3eee1f/68747470733a2f2f6373732d747269636b732e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f31302f616c69676e2d73656c662e737667" alt="align-self" target="_blank" rel="noopener" loading="lazy" class="cosmos-image" /></a></p><p>Permite que la alineación estándar (o lo que esté definido por align-items) se sobrescriba para ítems individuales.</p><p>Por favor consulte la explicación de la propiedad align-items para entender cuáles son los posibles valores.</p><p><code>. .item {</code></p><p><code>align-self: auto | flex-start | flex-end | center | baseline | stretch;</code></p><p><code>}</code></p><h4><strong>¡Importante!</strong></h4><ul><li><p>CSS solo ve la jerarquía de principal-secundario; no aplicará propiedades Flex a elementos que no estén directamente relacionados;</p></li><li><p>Para que las propiedades funcionen en elementos secundarios, los principales deben tener propiedad <code>display: flex;.</code></p></li><li><p>Las propiedades <code>float, clear y vertical-align</code> no tienen ningún efecto en flex-items.</p></li></ul><h4><strong>¿Vamos a practicar?</strong></h4><p><a
href="https://flexboxfroggy.com/" target="_blank" rel="noopener">Flexbox Froggy</a></p><h4><strong>Enlaces útiles</strong></h4><p>Al igual que con cualquier otra funcionalidad nueva que hemos aprendido, es fundamental practicar mucho e investigar siempre que tengamos dudas. A continuación se muestran algunos enlaces útiles.</p><p>Este contenido se basa en gran parte en el tutorial de <a
href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">CSS</a> Tricks, ¡con nuestros agradecimientos! Guarda en tus favoritos para consultar siempre que lo necesites.</p><p>La guía CSS Tricks también aborda algunos otros aspectos importantes de Flex: soporte de los navegadores, errores, propiedades relacionadas, prefijos y etc. Si tiene alguna duda que no se haya abordado en este artículo, puedes consultar estos temas relacionados en el enlace.</p><ul><li><p><a
href="https://developer.mozilla.org/es/docs/Learn/CSS/CSS_layout/Flexbox" target="_blank" rel="noopener">Flexbox en MDN</a></p></li><li><p><a
href="https://www.w3schools.com/csS/css3_flexbox.asp" target="_blank" rel="noopener">Flexbox en W3Schools</a></p></li></ul><p>¿Te gustó la publicación y quieres saber más? Aquí en <strong>Alura</strong> tenemos una <a
href="https://www.aluracursos.com/cursos-online-front-end" target="_blank" rel="noopener"><strong>formación front-end</strong></a> donde aprenderás más sobre <strong>HTML y CSS.</strong></p><p>Juliana Amoasei</p><p>Desarrolladora JS con experiencia multidisciplinaria. Siempre aprendiendo para enseñar y viceversa.</p></li></ul></div></body></html>